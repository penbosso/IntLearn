/**
 * @fileoverview Firestore Security Rules for the IntLearn application.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user-specific data and an
 * admin-ownership model for course content.  Authorization independence is
 * achieved by denormalizing the `adminId` from the `Course` document into its
 * subcollections (`topics`, `flashcards`, `questions`, `quizzes`).
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles.
 * - /courses/{courseId}: Stores course information, including the `adminId` of the course creator.
 * - /courses/{courseId}/topics/{topicId}: Stores topics within a course, with a denormalized `adminId`.
 * - /courses/{courseId}/topics/{topicId}/flashcards/{flashcardId}: Stores flashcards, with a denormalized `adminId`.
 * - /courses/{courseId}/topics/{topicId}/questions/{questionId}: Stores questions, with a denormalized `adminId`.
 * - /courses/{courseId}/topics/{topicId}/quizzes/{quizId}: Stores quizzes, with a denormalized `adminId`.
 * - /users/{userId}/enrollments/{enrollmentId}: Stores user enrollment data.
 * - /users/{userId}/quizAttempts/{quizAttemptId}: Stores user quiz attempts.
 * - /users/{userId}/performances/{performanceId}: Stores user performance data.
 * - /users/{userId}/userBadges/{userBadgeId}: Stores badges earned by users.
 * - /badges/{badgeId}: Stores information about available badges.
 *
 * Key Security Decisions:
 * - Users can only access their own data under the /users/{userId} collection.
 * - Course content can only be created, updated, or deleted by the course admin
 *   (identified by the denormalized `adminId` field).
 * - List operations on user-specific subcollections are allowed only for the owner.
 *
 * Denormalization for Authorization:
 * The `adminId` field is copied from the `/courses/{courseId}` document to
 * documents in its subcollections (/topics, /flashcards, /questions, /quizzes).
 * This allows for efficient security rules that don't require extra `get()` calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @path N/A (Helper Function)
     * @allow N/A (Helper Function)
     * @deny N/A (Helper Function)
     * @principle Verifies user authentication.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @path N/A (Helper Function)
     * @allow N/A (Helper Function)
     * @deny N/A (Helper Function)
     * @principle Enforces resource ownership.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the existing owner of the resource.
     * @path N/A (Helper Function)
     * @allow N/A (Helper Function)
     * @deny N/A (Helper Function)
     * @principle Enforces resource ownership and checks for existence before destructive operations.
     */
    function isExistingOwner(userId) {
      return isSignedIn() && isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user is the admin of the course.
     * @path N/A (Helper Function)
     * @allow N/A (Helper Function)
     * @deny N/A (Helper Function)
     * @principle Enforces course admin ownership.
     */
    function isAdmin(adminId) {
      return isSignedIn() && request.auth.uid == adminId;
    }

    /**
     * @description Checks if the authenticated user is the existing admin of the course.
     * @path N/A (Helper Function)
     * @allow N/A (Helper Function)
     * @deny N/A (Helper Function)
     * @principle Enforces course admin ownership and checks for existence before destructive operations.
     */
    function isExistingAdmin(adminId) {
      return isSignedIn() && isAdmin(adminId) && resource != null;
    }


    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their own profile.
     *   request.auth.uid = 'user123'
     * @allow (get) User with ID 'user123' reads their own profile.
     *   request.auth.uid = 'user123'
     * @allow (update) User with ID 'user123' updates their own profile.
     *   request.auth.uid = 'user123'
     * @deny (create) User with ID 'user456' tries to create a profile for 'user123'.
     *   request.auth.uid = 'user456'
     * @deny (get) User with ID 'user456' tries to read the profile of 'user123'.
     *   request.auth.uid = 'user456'
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for courses.
     * @path /courses/{courseId}
     * @allow (create) Admin with ID 'admin123' creates a new course.
     *   request.auth.uid = 'admin123', request.resource.data.adminId = 'admin123'
     * @allow (get) Any user can read a course.
     *   request.auth != null
     * @allow (update) Admin with ID 'admin123' updates a course they own.
     *   request.auth.uid = 'admin123', resource.data.adminId = 'admin123'
     * @deny (create) User with ID 'user456' tries to create a course with adminId 'admin123'.
     *   request.auth.uid = 'user456', request.resource.data.adminId = 'admin123'
     * @deny (update) User with ID 'user456' tries to update a course owned by 'admin123'.
     *   request.auth.uid = 'user456', resource.data.adminId = 'admin123'
     * @principle Enforces admin ownership for courses.
     */
    match /courses/{courseId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.adminId == request.auth.uid;
      allow update: if isExistingAdmin(resource.data.adminId);
      allow delete: if isExistingAdmin(resource.data.adminId);
    }

    /**
     * @description Rules for topics within a course.
     * @path /courses/{courseId}/topics/{topicId}
     * @allow (create) Admin with ID 'admin123' creates a new topic in their course.
     *   request.auth.uid = 'admin123', request.resource.data.adminId = 'admin123'
     * @allow (get) Any user can read a topic within a course.
     *   request.auth != null
     * @allow (update) Admin with ID 'admin123' updates a topic in their course.
     *   request.auth.uid = 'admin123', resource.data.adminId = 'admin123'
     * @deny (create) User with ID 'user456' tries to create a topic in a course owned by 'admin123'.
     *   request.auth.uid = 'user456', request.resource.data.adminId = 'admin123'
     * @deny (update) User with ID 'user456' tries to update a topic in a course owned by 'admin123'.
     *   request.auth.uid = 'user456', resource.data.adminId = 'admin123'
     * @principle Enforces admin ownership for topics, ensuring authorization independence.
     */
    match /courses/{courseId}/topics/{topicId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.adminId == request.auth.uid;
      allow update: if isExistingAdmin(resource.data.adminId);
      allow delete: if isExistingAdmin(resource.data.adminId);
    }

    /**
     * @description Rules for flashcards within a topic.
     * @path /courses/{courseId}/topics/{topicId}/flashcards/{flashcardId}
     * @allow (create) Admin with ID 'admin123' creates a new flashcard in their topic.
     *   request.auth.uid = 'admin123', request.resource.data.adminId = 'admin123'
     * @allow (get) Any user can read a flashcard within a topic.
     *   request.auth != null
     * @allow (update) Admin with ID 'admin123' updates a flashcard in their topic.
     *   request.auth.uid = 'admin123', resource.data.adminId = 'admin123'
     * @deny (create) User with ID 'user456' tries to create a flashcard in a topic owned by 'admin123'.
     *   request.auth.uid = 'user456', request.resource.data.adminId = 'admin123'
     * @deny (update) User with ID 'user456' tries to update a flashcard in a topic owned by 'admin123'.
     *   request.auth.uid = 'user456', resource.data.adminId = 'admin123'
     * @principle Enforces admin ownership for flashcards, ensuring authorization independence.
     */
    match /courses/{courseId}/topics/{topicId}/flashcards/{flashcardId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.adminId == request.auth.uid;
      allow update: if isExistingAdmin(resource.data.adminId);
      allow delete: if isExistingAdmin(resource.data.adminId);
    }

    /**
     * @description Rules for questions within a topic.
     * @path /courses/{courseId}/topics/{topicId}/questions/{questionId}
     * @allow (create) Admin with ID 'admin123' creates a new question in their topic.
     *   request.auth.uid = 'admin123', request.resource.data.adminId = 'admin123'
     * @allow (get) Any user can read a question within a topic.
     *   request.auth != null
     * @allow (update) Admin with ID 'admin123' updates a question in their topic.
     *   request.auth.uid = 'admin123', resource.data.adminId = 'admin123'
     * @deny (create) User with ID 'user456' tries to create a question in a topic owned by 'admin123'.
     *   request.auth.uid = 'user456', request.resource.data.adminId = 'admin123'
     * @deny (update) User with ID 'user456' tries to update a question in a topic owned by 'admin123'.
     *   request.auth.uid = 'user456', resource.data.adminId = 'admin123'
     * @principle Enforces admin ownership for questions, ensuring authorization independence.
     */
    match /courses/{courseId}/topics/{topicId}/questions/{questionId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.adminId == request.auth.uid;
      allow update: if isExistingAdmin(resource.data.adminId);
      allow delete: if isExistingAdmin(resource.data.adminId);
    }

    /**
     * @description Rules for quizzes within a topic.
     * @path /courses/{courseId}/topics/{topicId}/quizzes/{quizId}
     * @allow (create) Admin with ID 'admin123' creates a new quiz in their topic.
     *   request.auth.uid = 'admin123', request.resource.data.adminId = 'admin123'
     * @allow (get) Any user can read a quiz within a topic.
     *   request.auth != null
     * @allow (update) Admin with ID 'admin123' updates a quiz in their topic.
     *   request.auth.uid = 'admin123', resource.data.adminId = 'admin123'
     * @deny (create) User with ID 'user456' tries to create a quiz in a topic owned by 'admin123'.
     *   request.auth.uid = 'user456', request.resource.data.adminId = 'admin123'
     * @deny (update) User with ID 'user456' tries to update a quiz in a topic owned by 'admin123'.
     *   request.auth.uid = 'user456', resource.data.adminId = 'admin123'
     * @principle Enforces admin ownership for quizzes, ensuring authorization independence.
     */
    match /courses/{courseId}/topics/{topicId}/quizzes/{quizId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.adminId == request.auth.uid;
      allow update: if isExistingAdmin(resource.data.adminId);
      allow delete: if isExistingAdmin(resource.data.adminId);
    }

    /**
     * @description Rules for user enrollments.
     * @path /users/{userId}/enrollments/{enrollmentId}
     * @allow (create) User with ID 'user123' creates their own enrollment.
     *   request.auth.uid = 'user123'
     * @allow (get) User with ID 'user123' reads their own enrollment.
     *   request.auth.uid = 'user123'
     * @allow (update) User with ID 'user123' updates their own enrollment.
     *   request.auth.uid = 'user123'
     * @deny (create) User with ID 'user456' tries to create an enrollment for 'user123'.
     *   request.auth.uid = 'user456'
     * @deny (get) User with ID 'user456' tries to read the enrollment of 'user123'.
     *   request.auth.uid = 'user456'
     *  @principle Enforces document ownership for user enrollments.
     */
    match /users/{userId}/enrollments/{enrollmentId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user quiz attempts.
     * @path /users/{userId}/quizAttempts/{quizAttemptId}
     * @allow (create) User with ID 'user123' creates their own quiz attempt.
     *   request.auth.uid = 'user123'
     * @allow (get) User with ID 'user123' reads their own quiz attempt.
     *   request.auth.uid = 'user123'
     * @allow (update) User with ID 'user123' updates their own quiz attempt.
     *   request.auth.uid = 'user123'
     * @deny (create) User with ID 'user456' tries to create a quiz attempt for 'user123'.
     *   request.auth.uid = 'user456'
     * @deny (get) User with ID 'user456' tries to read the quiz attempt of 'user123'.
     *   request.auth.uid = 'user456'
     * @principle Enforces document ownership for user quiz attempts.
     */
    match /users/{userId}/quizAttempts/{quizAttemptId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user performance data.
     * @path /users/{userId}/performances/{performanceId}
     * @allow (create) User with ID 'user123' creates their own performance data.
     *   request.auth.uid = 'user123'
     * @allow (get) User with ID 'user123' reads their own performance data.
     *   request.auth.uid = 'user123'
     * @allow (update) User with ID 'user123' updates their own performance data.
     *   request.auth.uid = 'user123'
     * @deny (create) User with ID 'user456' tries to create performance data for 'user123'.
     *   request.auth.uid = 'user456'
     * @deny (get) User with ID 'user456' tries to read the performance data of 'user123'.
     *   request.auth.uid = 'user456'
     * @principle Enforces document ownership for user performance data.
     */
    match /users/{userId}/performances/{performanceId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user badges.
     * @path /users/{userId}/userBadges/{userBadgeId}
     * @allow (create) User with ID 'user123' creates their own user badge.
     *   request.auth.uid = 'user123'
     * @allow (get) User with ID 'user123' reads their own user badge.
     *   request.auth.uid = 'user123'
     * @allow (update) User with ID 'user123' updates their own user badge.
     *   request.auth.uid = 'user123'
     * @deny (create) User with ID 'user456' tries to create a user badge for 'user123'.
     *   request.auth.uid = 'user456'
     * @deny (get) User with ID 'user456' tries to read the user badge of 'user123'.
     *   request.auth.uid = 'user456'
     * @principle Enforces document ownership for user badges.
     */
    match /users/{userId}/userBadges/{userBadgeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for available badges.
     * @path /badges/{badgeId}
     * @allow (get) Any user can read a badge.
     *   request.auth != null
     * @deny (create) No one can create a badge.
     *   Always denied
     * @principle Allows public read access for badges, restricts creation, update, and delete.
     */
    match /badges/{badgeId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

     /**
      * @description Rules for flashcardMastery.
      * @path /users/{userId}/flashcardMastery
      * @allow (list) User with ID 'user123' can list own flashcardMastery records.
      *   request.auth.uid = 'user123'
      * @deny (list) User with ID 'user456' tries to list flashcardMastery records for user 'user123'.
      *   request.auth.uid = 'user456'
      * @principle Enforces document ownership for user flashcardMastery records.
      */
     match /users/{userId}/flashcardMastery/{flashcardMasteryId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }
  }
}